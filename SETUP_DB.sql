-- ============================================================================
-- SETUP_DB.sql (CANONICAL)
-- AUTO-GENERATED FROM supabase/migrations/*.sql
--
-- HOW TO USE:
-- 1) For a NEW database, run this file once in Supabase SQL Editor.
-- 2) For an EXISTING database, prefer incremental migrations.
--
-- DO NOT EDIT THIS FILE MANUALLY.
-- Source of truth: supabase/migrations/*.sql
-- Regenerate with: npm run db:bundle
-- ============================================================================

-- ============================================================
-- MIGRATION: 00001_initial_schema.sql
-- ============================================================

-- Financeiro Lazy: schema inicial + RLS multi-tenant (org/workspace)
-- Roles: admin, financeiro, leitura

-- Extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enums
CREATE TYPE transaction_type AS ENUM ('income', 'expense', 'transfer');
CREATE TYPE transaction_status AS ENUM ('pending', 'cleared', 'reconciled', 'cancelled');
CREATE TYPE member_role AS ENUM ('admin', 'financeiro', 'leitura');
CREATE TYPE recurrence_freq AS ENUM ('weekly', 'monthly', 'yearly');

-- Orgs (workspaces)
CREATE TABLE orgs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Profiles (extends auth.users)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Org members (RBAC)
CREATE TABLE org_members (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role member_role NOT NULL DEFAULT 'leitura',
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(org_id, user_id)
);
CREATE INDEX idx_org_members_org ON org_members(org_id);
CREATE INDEX idx_org_members_user ON org_members(user_id);

-- Accounts (contas: banco, cartÃ£o, caixa)
CREATE TABLE accounts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  type TEXT NOT NULL DEFAULT 'bank', -- bank, credit_card, cash, other
  currency TEXT NOT NULL DEFAULT 'BRL',
  initial_balance DECIMAL(18,4) DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_accounts_org ON accounts(org_id);

-- Categories
CREATE TABLE categories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  type transaction_type NOT NULL, -- income or expense (transfer uses both)
  parent_id UUID REFERENCES categories(id) ON DELETE SET NULL,
  icon TEXT,
  color TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(org_id, name, type)
);
CREATE INDEX idx_categories_org ON categories(org_id);

-- Tags
CREATE TABLE tags (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(org_id, name)
);
CREATE INDEX idx_tags_org ON tags(org_id);

-- Transactions
CREATE TABLE transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  type transaction_type NOT NULL,
  status transaction_status NOT NULL DEFAULT 'cleared',
  amount DECIMAL(18,4) NOT NULL,
  currency TEXT NOT NULL DEFAULT 'BRL',
  account_id UUID NOT NULL REFERENCES accounts(id) ON DELETE RESTRICT,
  transfer_account_id UUID REFERENCES accounts(id) ON DELETE SET NULL, -- only for type=transfer
  category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
  description TEXT,
  date DATE NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  deleted_at TIMESTAMPTZ, -- soft delete
  CONSTRAINT no_transfer_self CHECK (account_id != transfer_account_id OR transfer_account_id IS NULL)
);
CREATE INDEX idx_transactions_org ON transactions(org_id);
CREATE INDEX idx_transactions_date ON transactions(org_id, date);
CREATE INDEX idx_transactions_account ON transactions(account_id);
CREATE INDEX idx_transactions_deleted ON transactions(org_id) WHERE deleted_at IS NULL;

-- Transaction tags (many-to-many)
CREATE TABLE transaction_tags (
  transaction_id UUID NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
  tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  PRIMARY KEY (transaction_id, tag_id)
);

-- Recurring rules
CREATE TABLE recurring_rules (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  amount DECIMAL(18,4) NOT NULL,
  account_id UUID NOT NULL REFERENCES accounts(id) ON DELETE RESTRICT,
  category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
  frequency recurrence_freq NOT NULL,
  day_of_month INT CHECK (day_of_month IS NULL OR (day_of_month >= 1 AND day_of_month <= 31)),
  day_of_week INT CHECK (day_of_week IS NULL OR (day_of_week >= 0 AND day_of_week <= 6)),
  start_date DATE NOT NULL,
  end_date DATE,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_recurring_rules_org ON recurring_rules(org_id);

-- Recurring runs (log of generated transactions)
CREATE TABLE recurring_runs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  rule_id UUID NOT NULL REFERENCES recurring_rules(id) ON DELETE CASCADE,
  transaction_id UUID REFERENCES transactions(id) ON DELETE SET NULL,
  run_at TIMESTAMPTZ DEFAULT now(),
  success BOOLEAN NOT NULL
);
CREATE INDEX idx_recurring_runs_rule ON recurring_runs(rule_id);

-- Budgets (orÃ§amento por categoria/mÃªs)
CREATE TABLE budgets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
  month DATE NOT NULL, -- first day of month
  amount DECIMAL(18,4) NOT NULL,
  alert_threshold DECIMAL(5,2) DEFAULT 80, -- % para alertar
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(org_id, category_id, month)
);
CREATE INDEX idx_budgets_org_month ON budgets(org_id, month);

-- Attachments (Supabase Storage ref)
CREATE TABLE attachments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  transaction_id UUID NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
  storage_path TEXT NOT NULL,
  filename TEXT NOT NULL,
  content_type TEXT,
  size_bytes BIGINT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_attachments_transaction ON attachments(transaction_id);

-- Audit log (quem, quando, antes/depois, motivo, origem)
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  action TEXT NOT NULL, -- create, update, delete, restore
  table_name TEXT NOT NULL,
  record_id UUID,
  old_data JSONB,
  new_data JSONB,
  reason TEXT, -- justificativa
  origin TEXT NOT NULL DEFAULT 'UI', -- UI, API, import
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_audit_logs_org ON audit_logs(org_id);
CREATE INDEX idx_audit_logs_record ON audit_logs(table_name, record_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(org_id, created_at DESC);

-- API tokens (embed / integrations)
CREATE TABLE api_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE, -- hash do token (nunca guardar o token em claro)
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ
);
CREATE INDEX idx_api_tokens_org ON api_tokens(org_id);

-- RLS: helper para obter orgs do usuÃ¡rio
CREATE OR REPLACE FUNCTION public.user_org_ids()
RETURNS SETOF UUID AS $$
  SELECT org_id FROM org_members WHERE user_id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER STABLE;

-- RLS: role do usuÃ¡rio na org
CREATE OR REPLACE FUNCTION public.user_role_in_org(org_uuid UUID)
RETURNS member_role AS $$
  SELECT role FROM org_members WHERE org_id = org_uuid AND user_id = auth.uid() LIMIT 1;
$$ LANGUAGE sql SECURITY DEFINER STABLE;

-- RLS: pode escrever (admin ou financeiro)
CREATE OR REPLACE FUNCTION public.can_write_org(org_uuid UUID)
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM org_members
    WHERE org_id = org_uuid AND user_id = auth.uid() AND role IN ('admin', 'financeiro')
  );
$$ LANGUAGE sql SECURITY DEFINER STABLE;
GRANT EXECUTE ON FUNCTION public.user_org_ids() TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION public.user_role_in_org(UUID) TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION public.can_write_org(UUID) TO authenticated, anon, service_role;

-- Enable RLS on all tenant tables
ALTER TABLE orgs ENABLE ROW LEVEL SECURITY;
ALTER TABLE org_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE transaction_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE recurring_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE recurring_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE budgets ENABLE ROW LEVEL SECURITY;
ALTER TABLE attachments ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE api_tokens ENABLE ROW LEVEL SECURITY;

-- ============================================================
-- MIGRATION: 00002_rls_policies.sql
-- ============================================================

-- Ensure helper functions exist before creating policies.
-- Some environments run this migration without having executed the
-- helper-function section from 00001.
CREATE OR REPLACE FUNCTION public.user_org_ids()
RETURNS SETOF UUID AS $$
  SELECT org_id FROM public.org_members WHERE user_id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION public.user_role_in_org(org_uuid UUID)
RETURNS member_role AS $$
  SELECT role FROM public.org_members WHERE org_id = org_uuid AND user_id = auth.uid() LIMIT 1;
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION public.can_write_org(org_uuid UUID)
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.org_members
    WHERE org_id = org_uuid AND user_id = auth.uid() AND role IN ('admin', 'financeiro')
  );
$$ LANGUAGE sql SECURITY DEFINER STABLE;
GRANT EXECUTE ON FUNCTION public.user_org_ids() TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION public.user_role_in_org(UUID) TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION public.can_write_org(UUID) TO authenticated, anon, service_role;
-- RLS Policies: isolamento por org + RBAC (admin, financeiro, leitura)

-- Orgs: sÃ³ ver orgs em que Ã© membro
CREATE POLICY "orgs_select" ON orgs FOR SELECT
  USING (id IN (SELECT public.user_org_ids()));
CREATE POLICY "orgs_insert" ON orgs FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY "orgs_update" ON orgs FOR UPDATE
  USING (public.can_write_org(id));

-- Org members: ver/gerir apenas na prÃ³pria org (admin)
CREATE POLICY "org_members_select" ON org_members FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "org_members_insert" ON org_members FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "org_members_update" ON org_members FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "org_members_delete" ON org_members FOR DELETE
  USING (public.user_role_in_org(org_id) = 'admin');

-- Profiles: usuÃ¡rio vÃª/edita sÃ³ o prÃ³prio
CREATE POLICY "profiles_select" ON profiles FOR SELECT
  USING (auth.uid() = id);
CREATE POLICY "profiles_update" ON profiles FOR UPDATE
  USING (auth.uid() = id);

-- Accounts: leitura para todos da org; escrita admin/financeiro
CREATE POLICY "accounts_select" ON accounts FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "accounts_insert" ON accounts FOR INSERT
  WITH CHECK (org_id IN (SELECT public.user_org_ids()) AND public.can_write_org(org_id));
CREATE POLICY "accounts_update" ON accounts FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "accounts_delete" ON accounts FOR DELETE
  USING (public.can_write_org(org_id));

-- Categories
CREATE POLICY "categories_select" ON categories FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "categories_insert" ON categories FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "categories_update" ON categories FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "categories_delete" ON categories FOR DELETE
  USING (public.can_write_org(org_id));

-- Tags
CREATE POLICY "tags_select" ON tags FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "tags_insert" ON tags FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "tags_update" ON tags FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "tags_delete" ON tags FOR DELETE
  USING (public.can_write_org(org_id));

-- Transactions (inclui soft delete: deleted_at)
CREATE POLICY "transactions_select" ON transactions FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "transactions_insert" ON transactions FOR INSERT
  WITH CHECK (org_id IN (SELECT public.user_org_ids()) AND public.can_write_org(org_id));
CREATE POLICY "transactions_update" ON transactions FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "transactions_delete" ON transactions FOR UPDATE
  USING (public.can_write_org(org_id)); -- soft delete via updated_at/deleted_at

-- Transaction tags
CREATE POLICY "transaction_tags_select" ON transaction_tags FOR SELECT
  USING (
    transaction_id IN (SELECT id FROM transactions WHERE org_id IN (SELECT public.user_org_ids()))
  );
CREATE POLICY "transaction_tags_insert" ON transaction_tags FOR INSERT
  WITH CHECK (
    transaction_id IN (SELECT id FROM transactions t WHERE t.org_id IN (SELECT public.user_org_ids()) AND public.can_write_org(t.org_id))
  );
CREATE POLICY "transaction_tags_delete" ON transaction_tags FOR DELETE
  USING (
    transaction_id IN (SELECT id FROM transactions t WHERE public.can_write_org(t.org_id))
  );

-- Recurring rules
CREATE POLICY "recurring_rules_select" ON recurring_rules FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "recurring_rules_insert" ON recurring_rules FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "recurring_rules_update" ON recurring_rules FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "recurring_rules_delete" ON recurring_rules FOR DELETE
  USING (public.can_write_org(org_id));

-- Recurring runs
CREATE POLICY "recurring_runs_select" ON recurring_runs FOR SELECT
  USING (rule_id IN (SELECT id FROM recurring_rules WHERE org_id IN (SELECT public.user_org_ids())));
CREATE POLICY "recurring_runs_insert" ON recurring_runs FOR INSERT
  WITH CHECK (rule_id IN (SELECT id FROM recurring_rules r WHERE public.can_write_org(r.org_id)));

-- Budgets
CREATE POLICY "budgets_select" ON budgets FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "budgets_insert" ON budgets FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "budgets_update" ON budgets FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "budgets_delete" ON budgets FOR DELETE
  USING (public.can_write_org(org_id));

-- Attachments
CREATE POLICY "attachments_select" ON attachments FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "attachments_insert" ON attachments FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "attachments_delete" ON attachments FOR DELETE
  USING (public.can_write_org(org_id));

-- Audit logs: apenas leitura para membros da org
CREATE POLICY "audit_logs_select" ON audit_logs FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "audit_logs_insert" ON audit_logs FOR INSERT
  WITH CHECK (org_id IN (SELECT public.user_org_ids()));

-- API tokens: apenas admin
CREATE POLICY "api_tokens_select" ON api_tokens FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()) AND public.user_role_in_org(org_id) = 'admin');
CREATE POLICY "api_tokens_insert" ON api_tokens FOR INSERT
  WITH CHECK (public.user_role_in_org(org_id) = 'admin');
CREATE POLICY "api_tokens_update" ON api_tokens FOR UPDATE
  USING (public.user_role_in_org(org_id) = 'admin');
CREATE POLICY "api_tokens_delete" ON api_tokens FOR DELETE
  USING (public.user_role_in_org(org_id) = 'admin');

-- ============================================================
-- MIGRATION: 00003_storage_bucket.sql
-- ============================================================

-- Storage bucket para anexos (por org)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'attachments',
  'attachments',
  false,
  5242880, -- 5MB
  ARRAY['image/jpeg', 'image/png', 'image/gif', 'application/pdf']
)
ON CONFLICT (id) DO NOTHING;

-- RLS: usuário só acessa arquivos de orgs em que é membro
-- Path format: {org_id}/{transaction_id}/{filename}
CREATE POLICY "attachments_read" ON storage.objects FOR SELECT
  USING (
    bucket_id = 'attachments'
    AND (storage.foldername(name))[1]::uuid IN (SELECT org_id FROM public.org_members WHERE user_id = auth.uid())
  );
CREATE POLICY "attachments_insert" ON storage.objects FOR INSERT
  WITH CHECK (
    bucket_id = 'attachments'
    AND (storage.foldername(name))[1]::uuid IN (SELECT org_id FROM public.org_members WHERE user_id = auth.uid() AND role IN ('admin', 'financeiro'))
  );
CREATE POLICY "attachments_delete" ON storage.objects FOR DELETE
  USING (
    bucket_id = 'attachments'
    AND (storage.foldername(name))[1]::uuid IN (SELECT org_id FROM public.org_members WHERE user_id = auth.uid() AND role IN ('admin', 'financeiro'))
  );

-- ============================================================
-- MIGRATION: 00004_seed_demo.sql
-- ============================================================

-- Seed opcional para demo (rodar manualmente após criar primeiro usuário)
-- Uso: substitua 'SEED_USER_ID' pelo auth.uid() do usuário após signup.

-- Exemplo (descomente e ajuste USER_ID):
/*
DO $$
DECLARE
  uid UUID := 'SEED_USER_ID';
  oid UUID;
  aid UUID;
  cid_inc UUID;
  cid_exp UUID;
  tid UUID;
BEGIN
  INSERT INTO orgs (id, name, slug) VALUES
    (uuid_generate_v4(), 'Minha Empresa', 'minha-empresa')
    RETURNING id INTO oid;

  INSERT INTO org_members (org_id, user_id, role) VALUES (oid, uid, 'admin');

  INSERT INTO profiles (id, full_name) VALUES (uid, 'Usuário Demo') ON CONFLICT (id) DO UPDATE SET full_name = 'Usuário Demo';

  INSERT INTO accounts (org_id, name, type) VALUES
    (oid, 'Conta Corrente', 'bank'),
    (oid, 'Cartão de Crédito', 'credit_card'),
    (oid, 'Carteira', 'cash')
    RETURNING id INTO aid;

  SELECT id INTO cid_inc FROM categories WHERE org_id = oid AND type = 'income' LIMIT 1;
  IF cid_inc IS NULL THEN
    INSERT INTO categories (org_id, name, type) VALUES (oid, 'Salário', 'income'), (oid, 'Outros', 'income') RETURNING id INTO cid_inc;
  END IF;
  INSERT INTO categories (org_id, name, type) VALUES (oid, 'Alimentação', 'expense'), (oid, 'Transporte', 'expense'), (oid, 'Moradia', 'expense'), (oid, 'Lazer', 'expense') ON CONFLICT DO NOTHING;
  SELECT id INTO cid_exp FROM categories WHERE org_id = oid AND type = 'expense' LIMIT 1;

  INSERT INTO transactions (org_id, type, status, amount, account_id, category_id, description, date, created_by)
  VALUES
    (oid, 'income', 'cleared', 5000, aid, cid_inc, 'Salário', date_trunc('month', current_date)::date + 4, uid),
    (oid, 'expense', 'cleared', -1200, aid, cid_exp, 'Aluguel', date_trunc('month', current_date)::date + 5, uid),
    (oid, 'expense', 'cleared', -150, aid, cid_exp, 'Internet', current_date - 2, uid);
END $$;
*/

-- ============================================================
-- MIGRATION: 00005_distribuicao_alertas.sql
-- ============================================================

-- MÃ³dulo DistribuiÃ§Ã£o + Alertas (Cofre ClÃ¡ssico)
-- Basis points: 100% = 10000

CREATE TYPE base_income_mode AS ENUM ('current_month', 'avg_3m', 'avg_6m', 'planned_manual');
CREATE TYPE distribution_edit_mode AS ENUM ('auto', 'manual');
CREATE TYPE alert_severity AS ENUM ('info', 'warn', 'critical');

-- Distributions (template por org)
CREATE TABLE distributions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  is_default BOOLEAN DEFAULT false,
  mode distribution_edit_mode NOT NULL DEFAULT 'auto',
  base_income_mode base_income_mode NOT NULL DEFAULT 'current_month',
  planned_income DECIMAL(18,4), -- usado quando base_income_mode = planned_manual
  active_from DATE,
  active_to DATE,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_distributions_org ON distributions(org_id);
CREATE UNIQUE INDEX idx_distributions_org_default ON distributions(org_id) WHERE is_default = true;

-- Buckets de uma distribution (2 a 8, soma percent_bps = 10000)
CREATE TABLE distribution_buckets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  distribution_id UUID NOT NULL REFERENCES distributions(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  percent_bps INT NOT NULL CHECK (percent_bps >= 0 AND percent_bps <= 10000),
  color TEXT DEFAULT '#6366f1',
  icon TEXT,
  sort_order INT NOT NULL DEFAULT 0,
  is_flexible BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_distribution_buckets_dist ON distribution_buckets(distribution_id);

-- Categories: default bucket (mapeamento categoria -> bucket)
ALTER TABLE categories ADD COLUMN IF NOT EXISTS default_bucket_id UUID REFERENCES distribution_buckets(id) ON DELETE SET NULL;
CREATE INDEX idx_categories_default_bucket ON categories(default_bucket_id);

-- Transactions: bucket (pode ser inferido por category.default_bucket_id ou override)
ALTER TABLE transactions ADD COLUMN IF NOT EXISTS bucket_id UUID REFERENCES distribution_buckets(id) ON DELETE SET NULL;
CREATE INDEX idx_transactions_bucket ON transactions(org_id, bucket_id) WHERE deleted_at IS NULL;

-- Month snapshots (prÃ©-agregaÃ§Ã£o por org/mÃªs)
CREATE TABLE month_snapshots (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  month DATE NOT NULL,
  base_income DECIMAL(18,4) NOT NULL,
  base_income_mode base_income_mode NOT NULL,
  bucket_data JSONB NOT NULL DEFAULT '[]', -- [{ bucket_id, budget, spend, spend_pct, pace_ideal, projection }]
  day_ratio DECIMAL(10,4),
  total_spend DECIMAL(18,4),
  total_budget DECIMAL(18,4),
  computed_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(org_id, month)
);
CREATE INDEX idx_month_snapshots_org_month ON month_snapshots(org_id, month);

-- Alert definitions (catÃ¡logo estÃ¡tico; seed)
CREATE TABLE alert_definitions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  code TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  description TEXT,
  severity alert_severity NOT NULL,
  condition_expression TEXT,
  cooldown_hours INT NOT NULL DEFAULT 24,
  hysteresis_pct DECIMAL(5,2) DEFAULT 5,
  message_template TEXT NOT NULL,
  cta_primary TEXT,
  cta_secondary TEXT,
  channels TEXT[] DEFAULT ARRAY['in_app']
);
CREATE INDEX idx_alert_definitions_code ON alert_definitions(code);

-- Alerts (instÃ¢ncias emitidas)
CREATE TABLE alerts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  month DATE NOT NULL,
  alert_code TEXT NOT NULL,
  severity alert_severity NOT NULL,
  message TEXT NOT NULL,
  context_json JSONB DEFAULT '{}',
  cta_primary TEXT,
  cta_secondary TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  acknowledged_at TIMESTAMPTZ,
  snoozed_until TIMESTAMPTZ
);
CREATE INDEX idx_alerts_org_month ON alerts(org_id, month);
CREATE INDEX idx_alerts_org_created ON alerts(org_id, created_at DESC);

-- RLS
ALTER TABLE distributions ENABLE ROW LEVEL SECURITY;
ALTER TABLE distribution_buckets ENABLE ROW LEVEL SECURITY;
ALTER TABLE month_snapshots ENABLE ROW LEVEL SECURITY;
ALTER TABLE alert_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE alerts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "distributions_select" ON distributions FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "distributions_insert" ON distributions FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "distributions_update" ON distributions FOR UPDATE
  USING (public.can_write_org(org_id));
CREATE POLICY "distributions_delete" ON distributions FOR DELETE
  USING (public.can_write_org(org_id));

CREATE POLICY "distribution_buckets_select" ON distribution_buckets FOR SELECT
  USING (distribution_id IN (SELECT id FROM distributions WHERE org_id IN (SELECT public.user_org_ids())));
CREATE POLICY "distribution_buckets_insert" ON distribution_buckets FOR INSERT
  WITH CHECK (distribution_id IN (SELECT id FROM distributions d WHERE public.can_write_org(d.org_id)));
CREATE POLICY "distribution_buckets_update" ON distribution_buckets FOR UPDATE
  USING (distribution_id IN (SELECT id FROM distributions d WHERE public.can_write_org(d.org_id)));
CREATE POLICY "distribution_buckets_delete" ON distribution_buckets FOR DELETE
  USING (distribution_id IN (SELECT id FROM distributions d WHERE public.can_write_org(d.org_id)));

CREATE POLICY "month_snapshots_select" ON month_snapshots FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "month_snapshots_insert" ON month_snapshots FOR INSERT
  WITH CHECK (public.can_write_org(org_id));
CREATE POLICY "month_snapshots_update" ON month_snapshots FOR UPDATE
  USING (public.can_write_org(org_id));

CREATE POLICY "alert_definitions_select" ON alert_definitions FOR SELECT
  USING (true);

CREATE POLICY "alerts_select" ON alerts FOR SELECT
  USING (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "alerts_insert" ON alerts FOR INSERT
  WITH CHECK (org_id IN (SELECT public.user_org_ids()));
CREATE POLICY "alerts_update" ON alerts FOR UPDATE
  USING (org_id IN (SELECT public.user_org_ids()));

-- Seed alert_definitions (base)
INSERT INTO alert_definitions (code, name, severity, message_template, cta_primary, cta_secondary, cooldown_hours) VALUES
  ('bucket_70', 'Bucket 70%', 'warn', '{bucket} atingiu 70% do orÃ§amento.', 'Ajustar orÃ§amento', 'Reclassificar', 24),
  ('bucket_90', 'Bucket 90%', 'warn', '{bucket} atingiu 90% do orÃ§amento.', 'Ajustar orÃ§amento', NULL, 24),
  ('bucket_over', 'Bucket estouro', 'critical', '{bucket} estourou o orÃ§amento.', 'Ajustar distribuiÃ§Ã£o', NULL, 12),
  ('pace_15', 'Ritmo 15% acima', 'warn', 'Gasto em {bucket} estÃ¡ 15% acima do ritmo ideal.', 'Ver transaÃ§Ãµes', NULL, 24),
  ('pace_30', 'Ritmo 30% acima', 'critical', 'Gasto em {bucket} estÃ¡ 30% acima do ritmo ideal.', 'Ajustar orÃ§amento', NULL, 24),
  ('projection', 'ProjeÃ§Ã£o de fechamento', 'warn', 'Se continuar assim, {bucket} fecha em {projection_pct}%.', 'Ajustar gastos', NULL, 24),
  ('concentration_bucket', 'ConcentraÃ§Ã£o em um bucket', 'warn', 'Um bucket representa mais de 60% dos gastos.', 'Ver distribuiÃ§Ã£o', NULL, 24),
  ('concentration_top5', 'Top 5 transaÃ§Ãµes', 'warn', 'Poucas transaÃ§Ãµes concentram mais da metade do gasto em {bucket}.', 'Ver transaÃ§Ãµes', NULL, 24),
  ('pending_pct', 'PendÃªncias por %', 'warn', 'Mais de 10% das despesas sem bucket.', 'Reclassificar pendentes', NULL, 24),
  ('pending_count', 'PendÃªncias por quantidade', 'warn', '20+ transaÃ§Ãµes sem categoria/bucket neste mÃªs.', 'Reclassificar pendentes', NULL, 24)
ON CONFLICT (code) DO NOTHING;

-- ============================================================
-- MIGRATION: 00005_org_bootstrap_policy.sql
-- ============================================================

-- Permite bootstrap do primeiro membro admin em uma org recem-criada
-- sem abrir permissao de escrita para membros aleatorios.

DROP POLICY IF EXISTS "org_members_insert" ON org_members;

CREATE POLICY "org_members_insert" ON org_members
FOR INSERT
WITH CHECK (
  auth.uid() IS NOT NULL
  AND (
    EXISTS (
      SELECT 1
      FROM org_members writer_member
      WHERE writer_member.org_id = org_members.org_id
        AND writer_member.user_id = auth.uid()
        AND writer_member.role IN ('admin'::member_role, 'financeiro'::member_role)
    )
    OR (
      auth.uid() = user_id
      AND role = 'admin'::member_role
      AND NOT EXISTS (
        SELECT 1
        FROM org_members existing_member
        WHERE existing_member.org_id = org_members.org_id
      )
    )
  )
);

-- ============================================================
-- MIGRATION: 00006_credit_card_fields.sql
-- ============================================================

-- Campos para gestão de cartão de crédito e vencimento/fatura
ALTER TABLE accounts
  ADD COLUMN IF NOT EXISTS is_credit_card BOOLEAN DEFAULT false;

ALTER TABLE accounts
  ADD COLUMN IF NOT EXISTS credit_limit DECIMAL(18,4) DEFAULT 0;

ALTER TABLE accounts
  ADD COLUMN IF NOT EXISTS closing_day INT
    CHECK (closing_day IS NULL OR (closing_day >= 1 AND closing_day <= 31));

ALTER TABLE accounts
  ADD COLUMN IF NOT EXISTS due_day INT
    CHECK (due_day IS NULL OR (due_day >= 1 AND due_day <= 31));

CREATE INDEX IF NOT EXISTS idx_accounts_credit_card ON accounts(org_id, is_credit_card);

-- Sincroniza flag para contas já tipadas como cartão
UPDATE accounts
SET is_credit_card = true
WHERE type = 'credit_card' AND (is_credit_card IS DISTINCT FROM true);

-- ============================================================
-- MIGRATION: 00007_emergency_reserve.sql
-- ============================================================

-- Add liquidity_type to accounts
ALTER TABLE accounts ADD COLUMN IF NOT EXISTS liquidity_type TEXT DEFAULT 'immediate'; -- immediate, d+1, d+30, locked

-- Ensure goals table exists (if not created in previous migrations) and has necessary columns
-- Based on goals.ts, it seems to be used. If it doesn't exist in previous migrations, we create it here.
CREATE TABLE IF NOT EXISTS goals (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    type TEXT NOT NULL DEFAULT 'savings', -- savings, emergency_fund, debt, reduction, purchase
    target_amount DECIMAL(18,4),
    target_date DATE,
    current_amount DECIMAL(18,4) DEFAULT 0,
    strategy TEXT DEFAULT 'manual', -- bucket_fraction, month_leftover, fixed_amount, manual
    
    -- Fields for specific strategies or types
    reduction_category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
    reduction_target_pct DECIMAL(5,2),
    baseline_amount DECIMAL(18,4),
    linked_bucket_id UUID, -- If we link to a distribution bucket
    
    status TEXT DEFAULT 'active', -- active, completed, paused, cancelled
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index for goals
CREATE INDEX IF NOT EXISTS idx_goals_org ON goals(org_id);

-- ============================================================
-- MIGRATION: 00008_emergency_goal_unique.sql
-- ============================================================

-- Ensure only one emergency_fund goal per organization.
-- This cleans legacy duplicates and prevents new ones at DB level.

WITH ranked AS (
  SELECT
    id,
    org_id,
    ROW_NUMBER() OVER (
      PARTITION BY org_id
      ORDER BY COALESCE(updated_at, created_at) DESC, created_at DESC
    ) AS rn
  FROM goals
  WHERE type = 'emergency_fund'
)
DELETE FROM goals g
USING ranked r
WHERE g.id = r.id
  AND r.rn > 1;

CREATE UNIQUE INDEX IF NOT EXISTS idx_goals_one_emergency_per_org
ON goals (org_id)
WHERE type = 'emergency_fund';
